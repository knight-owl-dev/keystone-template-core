#!/usr/bin/env bash
set -euo pipefail

# publish.sh — Convert Markdown chapters into publishable book formats
#
# This is the core publishing engine of Keystone. It reads the chapter list
# from publish.txt, applies Lua filters for custom formatting (dialogs,
# page breaks, poems, etc.), and invokes Pandoc to produce the final output.
#
# All book metadata — title, author, layout, cover image, etc. — is read
# exclusively from pandoc.yaml (bind-mounted as user-metadata.yaml inside
# the container). Environment-variable metadata injection has been removed
# because the Pandoc CLI corrupts unicode when metadata is passed via -M
# flags; a YAML metadata file avoids this problem entirely.
#
# Supports PDF (via XeLaTeX), EPUB, DOCX, and ODT. PDF layout variables (papersize,
# geometry, fontsize, fontfamily) and EPUB options (cover-image) are set
# directly in pandoc.yaml — Pandoc reads them natively from YAML metadata.
#
# Called by the Makefile's `book` and similar targets via
# docker compose exec inside the Keystone container.
#
# Environment:
#   KEYSTONE_PROJECT  — project name for output filename (optional, default: keystone)
#
# Usage: .pandoc/publish.sh <target> [<format>]
#   <target>  — the metadata file stem (e.g., "book" loads book.yaml)
#   <format>  — output format: pdf (default), epub, docx, or odt
#
# Output: ./artifacts/<project>-<target>-<date>.<format>

# generate timestamp
DATE=$(date +%Y%m%d)

# validate arguments
TARGET="${1:?Target required — e.g., publish.sh book [format]}"
FORMAT="${2:-pdf}"

# Pandoc supports many output formats, but each one we officially support must
# work correctly with the div handler system and Lua filters — limit to tested formats.
case "${FORMAT}" in
  pdf | epub | docx | odt) ;; # supported formats
  *)
    echo "ERROR: Unsupported format '${FORMAT}'. Use: pdf, epub, docx, or odt" >&2
    exit 1
    ;;
esac

# fallback if KEYSTONE_PROJECT is not set
PROJECT="${KEYSTONE_PROJECT:-keystone}"

# set paths
FILE_LIST="publish.txt"
OUTPUT="artifacts/${PROJECT}-${TARGET}-${DATE}.${FORMAT}"
mkdir -p artifacts

# Temp workspace for intermediate files shared between publish.sh and Lua filters.
# Individual paths are exported so each consumer reads its location from the
# environment — no hardcoded /tmp paths in Lua.
KEYSTONE_TMPDIR="$(mktemp -d /tmp/keystone.XXXXXX)"
trap 'rm -rf "${KEYSTONE_TMPDIR}"' EXIT

KEYSTONE_CSS_FONTS="${KEYSTONE_TMPDIR}/fonts.css"
KEYSTONE_CSS_DIVS="${KEYSTONE_TMPDIR}/divs.css"
export KEYSTONE_CSS_FONTS KEYSTONE_CSS_DIVS

METADATA="${TARGET}.yaml"

if [[ ! -f ".pandoc/metadata/${METADATA}" ]]; then
  echo "ERROR: Target metadata file not found: ${METADATA}" >&2
  echo "  Ensure '${TARGET}' is a valid target (e.g., 'book')." >&2
  exit 1
fi

# Build the file list, ignoring comments and blank lines
file_content=$(grep -Ev '^\s*#|^\s*$' "${FILE_LIST}" || true)
if [[ -z "${file_content}" ]]; then
  echo "ERROR: '${FILE_LIST}' is empty. Please add your chapter files." >&2
  echo "  For a working example, see: https://github.com/knight-owl-dev/keystone-hello-world" >&2
  exit 1
fi
readarray -t FILES <<< "${file_content}"

if [[ "${PROJECT}" == "keystone" ]]; then
  echo "WARN: You're using the default project name \"keystone\"..."
  echo "  Set KEYSTONE_PROJECT (via project.conf or your environment) to personalize your output."
fi

# Pandoc common options
# Reference: # https://pandoc.org/MANUAL.html
#
# Two Lua filters handle all custom processing:
#   1. keystone.lua — metadata validation and enrichment (must run first)
#   2. divs.lua     — single-pass dispatcher for all fenced-div handlers
# Both filters read CSS output paths from KEYSTONE_CSS_FONTS / KEYSTONE_CSS_DIVS
# (exported above via KEYSTONE_TMPDIR).
PANDOC_OPTS=(
  "${FILES[@]}"
  -o "${OUTPUT}"
  --table-of-contents
  --number-sections
  --data-dir=.pandoc
  --resource-path=.
  --metadata-file="${METADATA}"
  --lua-filter=keystone.lua
  --lua-filter=divs.lua
)

# Font pre-scan (KEYSTONE_FONT_SCAN_OUTPUT only — no PANDOC_OPTS changes)
#
# font-scan.lua walks the AST for content font references. publish.sh owns the
# temp file path — both the filter and its consumers read it from the environment.
if [[ "${FORMAT}" == "epub" ]]; then
  KEYSTONE_FONT_SCAN_OUTPUT="${KEYSTONE_TMPDIR}/font-scan.txt"
  export KEYSTONE_FONT_SCAN_OUTPUT

  pandoc --lua-filter=.pandoc/filters/font-scan.lua \
    "${FILES[@]}" --to=native -o /dev/null
fi

# Format-specific Pandoc options (PANDOC_OPTS only — no side effects)
case "${FORMAT}" in
  pdf)
    PANDOC_OPTS+=(--pdf-engine=xelatex)
    ;;
  epub)
    # Dependency: KEYSTONE_FONT_SCAN_OUTPUT
    #
    # Generate --epub-embed-font paths from metadata + pre-scan results.
    # The @font-face CSS is generated by keystone.lua; this step copies the
    # actual .otf files into the EPUB archive. System fonts (no path) use
    # CSS fallback stacks only.
    epub_font_paths=$(pandoc lua .pandoc/filters/lib/epub-font-paths.lua \
      .pandoc/metadata/user-metadata.yaml)
    if [[ -n "${epub_font_paths}" ]]; then
      while IFS= read -r font_path; do
        PANDOC_OPTS+=("--epub-embed-font=${font_path}")
      done <<< "${epub_font_paths}"
    fi
    ;;
esac

# Require user-metadata.yaml (pandoc.yaml on the host, bind-mounted by compose).
# The -s check uses the filesystem path; --metadata-file uses the Pandoc-relative
# path (resolved via --data-dir=.pandoc). The mismatch is intentional.
if [[ -s .pandoc/metadata/user-metadata.yaml ]]; then
  PANDOC_OPTS+=(--metadata-file=user-metadata.yaml)
else
  echo "ERROR: user-metadata.yaml is missing or empty (bind-mounted from pandoc.yaml)." >&2
  echo "  Ensure it exists and contains your book metadata." >&2
  exit 1
fi

# build with Pandoc
echo "Publishing target: '${TARGET}' | format: ${FORMAT}"
pandoc "${PANDOC_OPTS[@]}"
echo "OK: ${OUTPUT}"
echo ""
